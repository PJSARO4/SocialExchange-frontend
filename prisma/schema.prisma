// Prisma schema for Social Exchange
// Supports NextAuth + Instagram/Facebook OAuth

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// NextAuth Required Models
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?

  accounts      Account[]
  sessions      Session[]
  socialFeeds   SocialFeed[]
  content       Content[]
  scheduledPosts ScheduledPost[]

  // Market system
  wallet        Wallet?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// Social Feed Models (Instagram, Facebook, etc.)
// ============================================

model SocialFeed {
  id                  String       @id @default(cuid())
  userId              String
  user                User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Platform info
  platform            Platform
  platformAccountId   String       // Instagram user ID, Facebook page ID, etc.
  handle              String       // @username
  displayName         String
  profilePictureUrl   String?

  // OAuth tokens (encrypted in production)
  accessToken         String       @db.Text
  accessTokenExpires  DateTime?
  refreshToken        String?      @db.Text

  // Connection state
  isConnected         Boolean      @default(true)
  lastSyncAt          DateTime?
  lastSyncError       String?

  // Automation settings
  automationEnabled   Boolean      @default(false)
  controlMode         ControlMode  @default(MANUAL)

  // Cached metrics (refreshed periodically)
  followers           Int          @default(0)
  following           Int          @default(0)
  postsCount          Int          @default(0)
  engagementRate      Float        @default(0)
  avgLikesPerPost     Int          @default(0)
  avgCommentsPerPost  Int          @default(0)

  // Relations
  scheduledPosts      ScheduledPostNew[]
  metrics             FeedMetricsHistory[]
  automationRules     AutomationRule[]
  automationActions   AutomationAction[]
  rateLimits          RateLimit[]
  jobQueue            JobQueue[]

  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt

  @@unique([userId, platform, platformAccountId])
  @@index([userId])
  @@index([platform])
}

model FeedMetricsHistory {
  id            String     @id @default(cuid())
  feedId        String
  feed          SocialFeed @relation(fields: [feedId], references: [id], onDelete: Cascade)

  followers     Int
  following     Int
  postsCount    Int
  engagementRate Float

  recordedAt    DateTime   @default(now())

  @@index([feedId, recordedAt])
}

// ============================================
// Content Library Models
// ============================================

model Content {
  id              String        @id @default(cuid())
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Content info
  type            ContentType
  title           String?
  description     String?       @db.Text

  // File storage
  fileName        String
  fileSize        Int
  mimeType        String
  storageUrl      String        // S3, Cloudinary, or local path
  thumbnailUrl    String?

  // Metadata
  width           Int?
  height          Int?
  duration        Int?          // For video, in seconds

  // Organization
  tags            String[]
  source          ContentSource @default(UPLOAD)

  // AI-generated content
  aiCaption       String?       @db.Text
  aiHashtags      String[]

  // Usage tracking
  usedInPosts     ScheduledPost[]

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([userId])
  @@index([type])
}

// ============================================
// Scheduling Models (Legacy - for NextAuth compat)
// ============================================

model ScheduledPost {
  id              String          @id @default(cuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  feedId          String

  contentId       String?
  content         Content?        @relation(fields: [contentId], references: [id], onDelete: SetNull)

  // Post content
  caption         String          @db.Text
  hashtags        String[]
  mediaUrls       String[]        // Can have multiple media items

  // Scheduling
  scheduledFor    DateTime
  timezone        String          @default("UTC")

  // Status tracking
  status          PostStatus      @default(SCHEDULED)
  postedAt        DateTime?
  platformPostId  String?         // ID returned by Instagram/Facebook after posting
  errorMessage    String?
  retryCount      Int             @default(0)

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([userId])
  @@index([feedId])
  @@index([scheduledFor])
  @@index([status])
}

// ============================================
// NEW: Scalable Scheduled Posts with Job Queue
// ============================================

model ScheduledPostNew {
  id              String           @id @default(cuid())
  feedId          String           @map("feed_id")
  feed            SocialFeed       @relation(fields: [feedId], references: [id], onDelete: Cascade)

  // Content
  caption         String           @db.Text
  mediaUrls       String[]         @map("media_urls")
  mediaType       MediaType        @default(IMAGE) @map("media_type")

  // Scheduling
  scheduledFor    DateTime         @map("scheduled_for")
  timezone        String           @default("UTC")

  // Status tracking
  status          ScheduleStatus   @default(PENDING)
  publishedAt     DateTime?        @map("published_at")
  instagramPostId String?          @map("instagram_post_id")

  // Job queue tracking
  jobId           String?          @map("job_id")
  attempts        Int              @default(0)
  lastError       String?          @map("last_error") @db.Text

  // Timestamps
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  @@index([feedId, status])
  @@index([scheduledFor, status])
  @@index([jobId])
  @@map("scheduled_posts_new")
}

enum MediaType {
  IMAGE
  VIDEO
  CAROUSEL
  REELS
}

enum ScheduleStatus {
  PENDING
  QUEUED
  PROCESSING
  PUBLISHED
  FAILED
  CANCELLED
}

// ============================================
// AUTOMATION RULES
// ============================================

model AutomationRule {
  id              String              @id @default(cuid())
  feedId          String              @map("feed_id")
  feed            SocialFeed          @relation(fields: [feedId], references: [id], onDelete: Cascade)

  // Rule definition
  name            String
  type            AutomationType
  enabled         Boolean             @default(false)

  // Rule settings (JSON for flexibility)
  settings        Json                @default("{}")

  // Execution schedule
  runInterval     Int?                @map("run_interval") // minutes between runs
  lastRunAt       DateTime?           @map("last_run_at")
  nextRunAt       DateTime?           @map("next_run_at")

  // Stats tracking
  actionsToday    Int                 @default(0) @map("actions_today")
  actionsTotal    Int                 @default(0) @map("actions_total")
  statsResetAt    DateTime            @default(now()) @map("stats_reset_at")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  // Relations
  actions         AutomationAction[]

  @@index([feedId, enabled])
  @@index([nextRunAt, enabled])
  @@map("automation_rules")
}

enum AutomationType {
  ENGAGEMENT      // Auto-like, auto-comment
  FOLLOW          // Auto-follow based on criteria
  DM              // Automated DMs
  COMMENT         // Auto-comment templates
}

// ============================================
// AUTOMATION ACTIONS (Execution Log)
// ============================================

model AutomationAction {
  id              String              @id @default(cuid())
  ruleId          String              @map("rule_id")
  feedId          String              @map("feed_id")
  feed            SocialFeed          @relation(fields: [feedId], references: [id], onDelete: Cascade)

  // Action details
  actionType      ActionType          @map("action_type")
  targetType      TargetType          @map("target_type")
  targetId        String?             @map("target_id")
  targetUsername  String?             @map("target_username")

  // For comments/DMs
  content         String?             @db.Text

  // Status tracking
  status          ActionStatus        @default(PENDING)
  executedAt      DateTime?           @map("executed_at")
  errorMessage    String?             @map("error_message") @db.Text

  // Job queue tracking
  jobId           String?             @map("job_id")
  attempts        Int                 @default(0)

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")

  // Relations
  rule            AutomationRule      @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([ruleId])
  @@index([feedId, actionType])
  @@index([status, createdAt])
  @@index([jobId])
  @@map("automation_actions")
}

enum ActionType {
  LIKE
  COMMENT
  FOLLOW
  UNFOLLOW
  DM
  PUBLISH
}

enum TargetType {
  POST
  USER
  STORY
}

enum ActionStatus {
  PENDING
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
  RATE_LIMITED
}

// ============================================
// RATE LIMITING
// ============================================

model RateLimit {
  id              String              @id @default(cuid())
  feedId          String              @map("feed_id")
  feed            SocialFeed          @relation(fields: [feedId], references: [id], onDelete: Cascade)

  // Action type being limited
  actionType      ActionType          @map("action_type")

  // Limits
  dailyLimit      Int                 @default(100) @map("daily_limit")
  hourlyLimit     Int                 @default(30) @map("hourly_limit")

  // Current counts
  dailyCount      Int                 @default(0) @map("daily_count")
  hourlyCount     Int                 @default(0) @map("hourly_count")

  // Reset timestamps
  dailyResetAt    DateTime            @map("daily_reset_at")
  hourlyResetAt   DateTime            @map("hourly_reset_at")

  // Temporary blocks
  blockedUntil    DateTime?           @map("blocked_until")
  blockReason     String?             @map("block_reason")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  @@unique([feedId, actionType])
  @@index([feedId])
  @@map("rate_limits")
}

// ============================================
// JOB QUEUE TRACKING
// ============================================

model JobQueue {
  id              String              @id @default(cuid())

  // Job identification
  queueName       String              @map("queue_name")
  jobType         JobType             @map("job_type")

  // Related entity
  entityType      String              @map("entity_type") // 'scheduled_post' | 'automation_action'
  entityId        String              @map("entity_id")
  feedId          String              @map("feed_id")
  feed            SocialFeed          @relation(fields: [feedId], references: [id], onDelete: Cascade)

  // Job data (serialized)
  payload         Json                @default("{}")

  // Scheduling
  scheduledFor    DateTime?           @map("scheduled_for")
  priority        Int                 @default(0)

  // Status
  status          JobStatus           @default(PENDING)
  processedAt     DateTime?           @map("processed_at")
  completedAt     DateTime?           @map("completed_at")

  // Retry handling
  attempts        Int                 @default(0)
  maxAttempts     Int                 @default(3) @map("max_attempts")
  lastError       String?             @map("last_error") @db.Text

  // Worker tracking
  workerId        String?             @map("worker_id")
  lockedAt        DateTime?           @map("locked_at")
  lockExpiry      DateTime?           @map("lock_expiry")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  @@index([queueName, status, scheduledFor])
  @@index([feedId])
  @@index([status, lockedAt])
  @@map("job_queue")
}

enum JobType {
  PUBLISH_POST
  AUTO_LIKE
  AUTO_COMMENT
  AUTO_FOLLOW
  AUTO_DM
  FETCH_ANALYTICS
}

enum JobStatus {
  PENDING
  LOCKED
  PROCESSING
  COMPLETED
  FAILED
  DEAD_LETTER
}

// ============================================
// GLOBAL SETTINGS & LIMITS
// ============================================

model SystemConfig {
  id              String              @id @default(cuid())
  key             String              @unique
  value           Json
  description     String?

  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  @@map("system_config")
}

// ============================================
// Enums (Original)
// ============================================

enum Platform {
  INSTAGRAM
  FACEBOOK
  TIKTOK
  TWITTER
  YOUTUBE
  LINKEDIN
}

enum ControlMode {
  AUTOPILOT    // Fully automated posting
  ESCROW       // Queued for review before posting
  MANUAL       // User initiates all posts
  OBSERVATION  // Read-only analytics
}

enum ContentType {
  IMAGE
  VIDEO
  CAROUSEL
  STORY
  REEL
}

enum ContentSource {
  UPLOAD       // Direct file upload
  CSV_IMPORT   // Bulk CSV import
  CLOUD_SYNC   // Google Drive, Dropbox, etc.
  AI_GENERATED // Created by AI
}

enum PostStatus {
  DRAFT
  SCHEDULED
  PENDING_REVIEW  // For escrow mode
  POSTING
  POSTED
  FAILED
  CANCELLED
}

// ============================================
// SExCOINS MARKET SYSTEM
// ============================================

// User wallet for SExCOINS
model Wallet {
  id              String              @id @default(cuid())
  userId          String              @unique @map("user_id")
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Balance
  balance         Decimal             @default(0) @db.Decimal(18, 4)  // SExCOINS balance
  lockedBalance   Decimal             @default(0) @db.Decimal(18, 4) @map("locked_balance")  // In pending orders

  // Lifetime stats
  totalDeposited  Decimal             @default(0) @db.Decimal(18, 4) @map("total_deposited")   // Total USD converted to coins
  totalWithdrawn  Decimal             @default(0) @db.Decimal(18, 4) @map("total_withdrawn")   // Total coins converted to USD
  totalTradingVolume Decimal          @default(0) @db.Decimal(18, 4) @map("total_trading_volume")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  // Relations
  transactions    WalletTransaction[]
  orders          MarketOrder[]
  shareholdings   Shareholding[]

  @@map("wallets")
}

// Wallet transaction log
model WalletTransaction {
  id              String              @id @default(cuid())
  walletId        String              @map("wallet_id")
  wallet          Wallet              @relation(fields: [walletId], references: [id], onDelete: Cascade)

  // Transaction details
  type            WalletTransactionType
  amount          Decimal             @db.Decimal(18, 4)  // Always positive
  balanceBefore   Decimal             @db.Decimal(18, 4) @map("balance_before")
  balanceAfter    Decimal             @db.Decimal(18, 4) @map("balance_after")

  // USD conversion (for deposits/withdrawals)
  usdAmount       Decimal?            @db.Decimal(18, 2) @map("usd_amount")
  exchangeRate    Decimal?            @db.Decimal(18, 4) @map("exchange_rate")  // 0.10 USD per coin
  feeAmount       Decimal?            @db.Decimal(18, 4) @map("fee_amount")
  feePercentage   Decimal?            @db.Decimal(5, 2) @map("fee_percentage")

  // Related entities
  orderId         String?             @map("order_id")
  brandId         String?             @map("brand_id")

  // External payment reference
  paymentProvider String?             @map("payment_provider")  // 'stripe', 'paypal', etc.
  paymentId       String?             @map("payment_id")
  paymentStatus   String?             @map("payment_status")

  // Metadata
  description     String?
  metadata        Json?               @default("{}")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")

  @@index([walletId, createdAt])
  @@index([type])
  @@map("wallet_transactions")
}

enum WalletTransactionType {
  DEPOSIT           // USD -> SExCOINS
  WITHDRAWAL        // SExCOINS -> USD (with 10% fee)
  IPO_FEE           // 1000 coins to go public
  BUY_SHARES        // Coins spent buying shares
  SELL_SHARES       // Coins received from selling shares
  TRADING_FEE       // 1% platform fee
  CREATOR_ROYALTY   // 2% royalty received
  MARKET_MAKER_BUY  // Platform bought from user
  MARKET_MAKER_SELL // Platform sold to user
  REFUND            // Order cancelled, coins returned
}

// Public Brand (Creator who went public)
model Brand {
  id              String              @id @default(cuid())
  ownerId         String              @map("owner_id")

  // Brand identity
  ticker          String              @unique  // e.g., $PJSARO (max 10 chars)
  name            String                       // Display name
  description     String?             @db.Text
  logoUrl         String?             @map("logo_url")
  bannerUrl       String?             @map("banner_url")

  // Linked social accounts (for display)
  socialFeedId    String?             @map("social_feed_id")
  instagramHandle String?             @map("instagram_handle")
  tiktokHandle    String?             @map("tiktok_handle")
  twitterHandle   String?             @map("twitter_handle")
  youtubeHandle   String?             @map("youtube_handle")

  // Share structure
  sharesIssued    Decimal             @db.Decimal(18, 4) @map("shares_issued")      // Total shares ever issued
  sharesOutstanding Decimal           @db.Decimal(18, 4) @map("shares_outstanding") // Shares held by investors
  sharesInReserve Decimal             @db.Decimal(18, 4) @map("shares_in_reserve")  // Platform reserve

  // Pricing
  currentPrice    Decimal             @db.Decimal(18, 4) @map("current_price")      // Current share price in coins
  previousPrice   Decimal             @db.Decimal(18, 4) @map("previous_price")     // For calculating change
  ipoPrice        Decimal             @db.Decimal(18, 4) @map("ipo_price")          // Original IPO price

  // Market metrics
  marketCap       Decimal             @db.Decimal(18, 4) @map("market_cap")         // price × outstanding shares
  volume24h       Decimal             @default(0) @db.Decimal(18, 4) @map("volume_24h")
  priceChange24h  Decimal             @default(0) @db.Decimal(8, 4) @map("price_change_24h")  // Percentage
  allTimeHigh     Decimal             @db.Decimal(18, 4) @map("all_time_high")
  allTimeLow      Decimal             @db.Decimal(18, 4) @map("all_time_low")

  // Creator earnings
  totalRoyalties  Decimal             @default(0) @db.Decimal(18, 4) @map("total_royalties")

  // Status
  status          BrandStatus         @default(ACTIVE)
  ipoDate         DateTime            @map("ipo_date")
  delistedAt      DateTime?           @map("delisted_at")
  delistReason    String?             @map("delist_reason")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  // Relations
  orders          MarketOrder[]
  shareholdings   Shareholding[]
  priceHistory    PriceHistory[]
  trades          Trade[]

  @@index([ownerId])
  @@index([status, marketCap])
  @@index([volume24h])
  @@map("brands")
}

enum BrandStatus {
  PENDING_IPO     // IPO in progress
  ACTIVE          // Trading enabled
  HALTED          // Trading temporarily stopped
  DELISTED        // Permanently removed from trading
}

// User's shareholdings in brands
model Shareholding {
  id              String              @id @default(cuid())
  walletId        String              @map("wallet_id")
  wallet          Wallet              @relation(fields: [walletId], references: [id], onDelete: Cascade)
  brandId         String              @map("brand_id")
  brand           Brand               @relation(fields: [brandId], references: [id], onDelete: Cascade)

  // Holdings
  quantity        Decimal             @db.Decimal(18, 4)
  lockedQuantity  Decimal             @default(0) @db.Decimal(18, 4) @map("locked_quantity")  // In pending sell orders

  // Cost basis for P&L calculation
  totalCost       Decimal             @db.Decimal(18, 4) @map("total_cost")      // Total coins spent
  averageCost     Decimal             @db.Decimal(18, 4) @map("average_cost")    // Average price per share

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  @@unique([walletId, brandId])
  @@index([walletId])
  @@index([brandId])
  @@map("shareholdings")
}

// Market orders (buy/sell)
model MarketOrder {
  id              String              @id @default(cuid())
  walletId        String              @map("wallet_id")
  wallet          Wallet              @relation(fields: [walletId], references: [id], onDelete: Cascade)
  brandId         String              @map("brand_id")
  brand           Brand               @relation(fields: [brandId], references: [id], onDelete: Cascade)

  // Order details
  side            OrderSide                    // BUY or SELL
  orderType       OrderType           @map("order_type")  // MARKET or LIMIT

  quantity        Decimal             @db.Decimal(18, 4)  // Shares to buy/sell
  limitPrice      Decimal?            @db.Decimal(18, 4) @map("limit_price")  // For limit orders

  // Execution
  filledQuantity  Decimal             @default(0) @db.Decimal(18, 4) @map("filled_quantity")
  averagePrice    Decimal?            @db.Decimal(18, 4) @map("average_price")
  totalValue      Decimal?            @db.Decimal(18, 4) @map("total_value")  // filledQty × avgPrice

  // Fees
  tradingFee      Decimal             @default(0) @db.Decimal(18, 4) @map("trading_fee")      // 1% to platform
  creatorRoyalty  Decimal             @default(0) @db.Decimal(18, 4) @map("creator_royalty")  // 2% to creator

  // Status
  status          OrderStatus         @default(PENDING)
  filledAt        DateTime?           @map("filled_at")
  cancelledAt     DateTime?           @map("cancelled_at")
  cancelReason    String?             @map("cancel_reason")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  // Relations
  trades          Trade[]

  @@index([walletId, status])
  @@index([brandId, status])
  @@index([status, createdAt])
  @@map("market_orders")
}

enum OrderSide {
  BUY
  SELL
}

enum OrderType {
  MARKET    // Execute immediately at current price
  LIMIT     // Execute only at specified price or better
}

enum OrderStatus {
  PENDING       // Awaiting execution
  PARTIAL       // Partially filled
  FILLED        // Completely filled
  CANCELLED     // Cancelled by user
  EXPIRED       // Time expired (for limit orders)
  REJECTED      // Rejected (insufficient funds, etc.)
}

// Executed trades
model Trade {
  id              String              @id @default(cuid())
  brandId         String              @map("brand_id")
  brand           Brand               @relation(fields: [brandId], references: [id], onDelete: Cascade)
  orderId         String              @map("order_id")
  order           MarketOrder         @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Trade details
  side            OrderSide           // BUY or SELL (from the order's perspective)
  quantity        Decimal             @db.Decimal(18, 4)
  price           Decimal             @db.Decimal(18, 4)
  totalValue      Decimal             @db.Decimal(18, 4) @map("total_value")

  // Counterparty (for P2P trades) or MARKET_MAKER
  counterpartyType CounterpartyType   @map("counterparty_type")
  counterpartyId  String?             @map("counterparty_id")  // Wallet ID if P2P

  // Fees deducted
  tradingFee      Decimal             @db.Decimal(18, 4) @map("trading_fee")
  creatorRoyalty  Decimal             @db.Decimal(18, 4) @map("creator_royalty")
  netValue        Decimal             @db.Decimal(18, 4) @map("net_value")  // Total after fees

  // Timestamps
  executedAt      DateTime            @default(now()) @map("executed_at")

  @@index([brandId, executedAt])
  @@index([orderId])
  @@map("trades")
}

enum CounterpartyType {
  USER            // P2P trade with another user
  MARKET_MAKER    // Platform acted as counterparty
}

// Price history for charts
model PriceHistory {
  id              String              @id @default(cuid())
  brandId         String              @map("brand_id")
  brand           Brand               @relation(fields: [brandId], references: [id], onDelete: Cascade)

  // OHLCV data
  openPrice       Decimal             @db.Decimal(18, 4) @map("open_price")
  highPrice       Decimal             @db.Decimal(18, 4) @map("high_price")
  lowPrice        Decimal             @db.Decimal(18, 4) @map("low_price")
  closePrice      Decimal             @db.Decimal(18, 4) @map("close_price")
  volume          Decimal             @db.Decimal(18, 4)  // Shares traded
  volumeCoins     Decimal             @db.Decimal(18, 4) @map("volume_coins")  // Value in coins

  // Time period
  interval        PriceInterval       // 1m, 5m, 1h, 1d, 1w
  periodStart     DateTime            @map("period_start")
  periodEnd       DateTime            @map("period_end")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")

  @@unique([brandId, interval, periodStart])
  @@index([brandId, interval, periodStart])
  @@map("price_history")
}

enum PriceInterval {
  MINUTE_1
  MINUTE_5
  MINUTE_15
  HOUR_1
  HOUR_4
  DAY_1
  WEEK_1
}

// Liquidity Reserve (Platform's market maker pool)
model LiquidityReserve {
  id              String              @id @default(cuid())

  // Coin reserve
  coinBalance     Decimal             @db.Decimal(18, 4) @map("coin_balance")

  // Stats
  totalIpoFees    Decimal             @default(0) @db.Decimal(18, 4) @map("total_ipo_fees")
  totalTradingFees Decimal            @default(0) @db.Decimal(18, 4) @map("total_trading_fees")
  totalWithdrawFees Decimal           @default(0) @db.Decimal(18, 4) @map("total_withdraw_fees")
  totalMarketMakerProfit Decimal      @default(0) @db.Decimal(18, 4) @map("total_mm_profit")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  @@map("liquidity_reserve")
}

// Market Maker holdings (platform's share inventory)
model MarketMakerInventory {
  id              String              @id @default(cuid())
  brandId         String              @unique @map("brand_id")

  // Holdings
  quantity        Decimal             @db.Decimal(18, 4)
  totalCost       Decimal             @db.Decimal(18, 4) @map("total_cost")
  averageCost     Decimal             @db.Decimal(18, 4) @map("average_cost")

  // Timestamps
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  @@map("market_maker_inventory")
}
